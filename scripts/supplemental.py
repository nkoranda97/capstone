import pylidc as pl
import numpy as np
import imageio.v3 as iio
import os
import shutil
import sys
from tqdm import tqdm
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import random

"""
This are extra functions that are not essential for project but useful for 
visualization and verification. These were 100% AI generated by Gemini 5 with 
little user input, understanding, or verification. Many of the organizational 
practices used in project are not implimented here as well. For example,
video will save in directory function is run without option to change. These are 
quick, dirty AI generated functions meant for quick troubleshooting.
"""

# --- Configuration ---
SCAN_ID_TO_FIND = None  # Set to specific ID or None
OUTPUT_FOLDER = "temp_scan_slices"
VIDEO_FILENAME = "scan_animation"  # Extension .gif will be added
FRAME_RATE = 15

# Standard Lung Window: Width 1500, Level -600 -> (-1350, 150)
WINDOW_RANGE = (-1350, 150)

# Explicitly force GIF format
VIDEO_FORMAT = "gif"


def _apply_window(image, window_range):
    """
    Applies the windowing (min/max clipping) and normalizes to 0-255 uint8.
    """
    lower, upper = window_range
    img = np.clip(image, lower, upper)
    img = (img - lower) / (upper - lower)
    img = (img * 255).astype(np.uint8)
    return img


def generate_simple_video(scan: pl.Scan):
    """
    Extracts all slices as simple grayscale images with lung windowing applied,
    then compiles them into a GIF.
    """
    print(f"\nProcessing Scan ID: {scan.id} ({scan.series_instance_uid})")

    # --- 1. Load Volume ---
    print("Loading scan volume...")
    try:
        vol = scan.to_volume()
    except Exception as e:
        raise RuntimeError(f"Failed to load volume data. Error: {e}")

    num_slices = vol.shape[2]
    print(f"Volume loaded. Shape: {vol.shape}. Total slices: {num_slices}")

    # --- 2. Setup Output Directory ---
    if os.path.exists(OUTPUT_FOLDER):
        shutil.rmtree(OUTPUT_FOLDER)
    os.makedirs(OUTPUT_FOLDER)
    print(f"Created temp folder: {OUTPUT_FOLDER}")

    image_files = []
    print(f"Processing {num_slices} slices...")

    # --- 3. Process Slices (Simple Grayscale) ---
    for k in tqdm(range(num_slices), desc="Extracting Images"):
        slice_data = vol[:, :, k]
        img_gray = _apply_window(slice_data, WINDOW_RANGE)

        fname = os.path.join(OUTPUT_FOLDER, f"slice_{k:04d}.png")
        iio.imwrite(fname, img_gray)
        image_files.append(fname)

    # --- 4. Compile GIF ---
    full_filename = f"{VIDEO_FILENAME}.{VIDEO_FORMAT}"
    print(
        f"Compiling {len(image_files)} frames into {VIDEO_FORMAT.upper()}: {full_filename}..."
    )

    try:
        frames = [iio.imread(f) for f in image_files]

        # Use PILLOW for GIF
        # Calculate duration in milliseconds per frame (1000ms / fps)
        duration_ms = 1000 / FRAME_RATE
        iio.imwrite(
            full_filename,
            frames,
            plugin="pillow",
            duration=duration_ms,
            loop=0,  # 0 = infinite loop
        )

        print(f"\nâœ… SUCCESS: Animation saved as: {full_filename}")

    except Exception as e:
        print(f"\nERROR: Compilation failed: {e}")
        sys.exit(1)

    # --- 5. Cleanup ---
    if os.path.exists(OUTPUT_FOLDER):
        shutil.rmtree(OUTPUT_FOLDER)
        print(f"Cleaned up temporary folder: {OUTPUT_FOLDER}")


def visualize_union_logic(scans: list[pl.Scan], window_range=(-1350, 150)):
    """
    Finds a random nodule with multiple annotations and displays:
    1. The Raw Disagreement (Before): What the radiologists actually drew.
    2. The Union Box (After): The 'Max Range' label we generate for YOLO.
    """

    # Helper to apply windowing (matching your dataset logic)
    def apply_window(img, window):
        min_hu, max_hu = window
        img = np.clip(img, min_hu, max_hu)
        img = (img - min_hu) / (max_hu - min_hu)
        return img * 255

    print("Searching for a nodule with disagreement...")

    # Shuffle scans to get a random one each time
    shuffled_scans = list(scans)
    random.shuffle(shuffled_scans)

    target_scan = None
    target_nodule = None
    target_k = None

    # 1. Find a suitable candidate (Nodule with >1 annotation)
    for scan in shuffled_scans:
        nodules = scan.cluster_annotations()
        for nod in nodules:
            if len(nod) > 1:  # We need disagreement to show the effect
                # Find the center slice of this nodule
                k_centroids = [ann.centroid[2] for ann in nod]
                k_center = int(np.mean(k_centroids))

                # Check if this slice actually has valid data

                vol = scan.to_volume()
                if k_center < vol.shape[2]:
                    target_scan = scan
                    target_nodule = nod
                    target_k = k_center
                    break

        if target_scan:
            break

    if not target_scan:
        print("Could not find a suitable nodule with multiple annotations.")
        return

    # 2. Retrieve Data
    vol = target_scan.to_volume()
    img_hu = vol[:, :, target_k]
    img_viz = apply_window(img_hu, window_range)

    # 3. Calculate Boxes
    # --- "Before": Individual Radiologist Boxes ---
    raw_boxes = []
    for ann in target_nodule:
        # bbox() returns tuple of slices: (i_slice, j_slice, k_slice)
        s_i, s_j, s_k = ann.bbox()

        # Only plot if this annotation actually extends to the current slice 'k'
        if s_k.start <= target_k < s_k.stop:
            # i is Row (y), j is Col (x)
            y0, y1 = s_i.start, s_i.stop
            x0, x1 = s_j.start, s_j.stop
            raw_boxes.append((x0, y0, x1, y1))

    # --- "After": The Union Box (Max Range) ---
    # Collect all coordinates from ALL annotations (even those not on this specific slice,
    # because we union the 3D volume first, then project)
    all_i0 = [ann.bbox()[0].start for ann in target_nodule]
    all_i1 = [ann.bbox()[0].stop for ann in target_nodule]
    all_j0 = [ann.bbox()[1].start for ann in target_nodule]
    all_j1 = [ann.bbox()[1].stop for ann in target_nodule]

    # The Union Logic: Min of starts, Max of stops
    u_y0, u_y1 = min(all_i0), max(all_i1)
    u_x0, u_x1 = min(all_j0), max(all_j1)

    # Calculate zoom margins (add padding around the union box)
    padding = 50  # pixels of padding around the lesion
    zoom_x0 = max(0, u_x0 - padding)
    zoom_x1 = min(img_viz.shape[1], u_x1 + padding)
    zoom_y0 = max(0, u_y0 - padding)
    zoom_y1 = min(img_viz.shape[0], u_y1 + padding)

    # 4. Plotting
    fig, axes = plt.subplots(1, 2, figsize=(12, 6))

    # Plot 1: Raw Disagreement
    axes[0].imshow(img_viz, cmap="gray")
    axes[0].set_title("Multiple Annotations")
    axes[0].axis("off")
    colors = ["cyan", "magenta", "yellow", "orange"]
    for idx, (x0, y0, x1, y1) in enumerate(raw_boxes):
        c = colors[idx % len(colors)]
        rect = Rectangle(
            (x0, y0), x1 - x0, y1 - y0, fill=False, color=c, lw=2, linestyle="--"
        )
        axes[0].add_patch(rect)
        # axes[0].text(x0, y0-2, f"R{idx+1}", color=c, fontsize=8, weight='bold')

    # Zoom in on the lesion
    axes[0].set_xlim(zoom_x0, zoom_x1)
    axes[0].set_ylim(zoom_y1, zoom_y0)  # y-axis is inverted in images

    # Plot 2: The Union Box
    axes[1].imshow(img_viz, cmap="gray")
    axes[1].set_title("Union Max Range")
    rect_union = Rectangle(
        (u_x0, u_y0), u_x1 - u_x0, u_y1 - u_y0, fill=False, color="lime", lw=3
    )
    axes[1].add_patch(rect_union)

    # Zoom in on the lesion
    axes[1].set_xlim(zoom_x0, zoom_x1)
    axes[1].set_ylim(zoom_y1, zoom_y0)  # y-axis is inverted in images
    axes[1].axis("off")

    plt.tight_layout()
    plt.show()

    print(f"Visualization for Patient: {target_scan.patient_id}")
    print(f"Slice Z-Index: {target_k}")
    print(f"Union Box Width: {u_x1 - u_x0}px, Height: {u_y1 - u_y0}px")
